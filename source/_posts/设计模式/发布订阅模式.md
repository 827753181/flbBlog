---
title: 发布订阅模式
date: 2020-03-16 11:43:03
tags:
---

和观察者模式的区别，观察者模式中， 被观察者 Subject 需要维护一套观察者 Observer 的集合，所有的 Observer 实现相同的接口。

在发布订阅模式中，一个订阅者，一个发布者，发布者和订阅者之间完全解耦，听过消息队列交流。

```typscript
function Emitter() {}

Emitter.prototype = {
  on(name: string, callback: Function, ctx: any) {
    const emitList = this.emitterList || (this.emitterList = {});
    (emitList[name] || (emitList[name] = [])).push({
      fn: callback,
      ctx,
    });
    return this;
  },
  emit(name: string) {
    const args = [].slice.call(arguments, 1);
    const emitList = this.emitterList || (this.emitterList = {});
    if (emitList[name]) {
      emitList[name].forEach(({ fn, ctx }) => fn.apply(ctx, args));
    }
  },
  once(name: string, callback: Function, ctx: any) {
    const self = this;
    function cb() {
      self.off(name, cb);
      callback.apply(ctx, arguments);
    }
    this.on(name, cb, ctx);
  },
  off(name: string, callback?: Function) {
    const emitList = this.emitterList || (this.emitterList = {});
    const liveCallback = [];
    if (emitList[name] && callback) {
      const itemList = emitList[name];
      for (let i = 0; i <= itemList.length - 1; i++) {
        if (itemList[i].fn !== callback) {
          liveCallback.push(itemList[i]);
        }
      }
    }
    if (liveCallback.length) {
      emitList[name] = liveCallback;
    } else {
      delete emitList[name];
    }
  },
};
let a = new Emitter();
a.on("1", function () {
  console.log(1);
});
a.once("1", function () {
  console.log("只调用一次");
});
a.emit("1");
a.emit("1");
```
